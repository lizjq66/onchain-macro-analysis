# test_network_analysis.py
#!/usr/bin/env python3
"""
ÁΩëÁªúÂàÜÊûêÂäüËÉΩÊµãËØïËÑöÊú¨
ÊºîÁ§∫DeFiÂçèËÆÆÁΩëÁªúÂàÜÊûêÁöÑÂÆåÊï¥ÊµÅÁ®ã
"""

import asyncio
import sys
import os
from datetime import datetime

# Ê∑ªÂä†È°πÁõÆÊ†πÁõÆÂΩïÂà∞Ë∑ØÂæÑ
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.analysis.network_analysis.protocol_network import protocol_network_analyzer
from src.data.data_pipeline import data_pipeline
from src.utils.logger import setup_logger

logger = setup_logger(__name__)

def create_sample_protocol_data():
    """ÂàõÂª∫Ê†∑Êú¨ÂçèËÆÆÊï∞ÊçÆÁî®‰∫éÊµãËØï"""
    sample_data = [
        {
            'protocol': 'uniswap',
            'chain': 'ethereum',
            'tvl_usd': 5000000000,  # 50‰∫ø
            'volume_24h': 1000000000,  # 10‰∫ø
            'metadata': {'category': 'dex'}
        },
        {
            'protocol': 'aave',
            'chain': 'ethereum', 
            'tvl_usd': 8000000000,  # 80‰∫ø
            'volume_24h': 500000000,  # 5‰∫ø
            'metadata': {'category': 'lending'}
        },
        {
            'protocol': 'compound',
            'chain': 'ethereum',
            'tvl_usd': 3000000000,  # 30‰∫ø
            'volume_24h': 200000000,  # 2‰∫ø
            'metadata': {'category': 'lending'}
        },
        {
            'protocol': 'makerdao',
            'chain': 'ethereum',
            'tvl_usd': 6000000000,  # 60‰∫ø
            'volume_24h': 100000000,  # 1‰∫ø
            'metadata': {'category': 'stablecoin'}
        },
        {
            'protocol': 'curve',
            'chain': 'ethereum',
            'tvl_usd': 4000000000,  # 40‰∫ø
            'volume_24h': 800000000,  # 8‰∫ø
            'metadata': {'category': 'dex'}
        },
        {
            'protocol': 'lido',
            'chain': 'ethereum',
            'tvl_usd': 15000000000,  # 150‰∫ø
            'volume_24h': 50000000,   # 5000‰∏á
            'metadata': {'category': 'staking'}
        },
        {
            'protocol': 'pancakeswap',
            'chain': 'bsc',
            'tvl_usd': 2000000000,  # 20‰∫ø
            'volume_24h': 400000000,  # 4‰∫ø
            'metadata': {'category': 'dex'}
        },
        {
            'protocol': 'aave',
            'chain': 'polygon',
            'tvl_usd': 500000000,   # 5‰∫ø
            'volume_24h': 50000000,  # 5000‰∏á
            'metadata': {'category': 'lending'}
        },
        {
            'protocol': 'uniswap',
            'chain': 'arbitrum',
            'tvl_usd': 1000000000,  # 10‰∫ø
            'volume_24h': 200000000,  # 2‰∫ø
            'metadata': {'category': 'dex'}
        },
        {
            'protocol': 'gmx',
            'chain': 'arbitrum',
            'tvl_usd': 800000000,   # 8‰∫ø
            'volume_24h': 300000000,  # 3‰∫ø
            'metadata': {'category': 'derivatives'}
        }
    ]
    
    return sample_data

async def test_network_construction():
    """ÊµãËØïÁΩëÁªúÊûÑÂª∫"""
    print("\nüîó Testing Network Construction")
    print("="*50)
    
    try:
        # Ëé∑ÂèñÊ†∑Êú¨Êï∞ÊçÆ
        sample_data = create_sample_protocol_data()
        print(f"üìä Created {len(sample_data)} sample protocols")
        
        # ÊûÑÂª∫ÁΩëÁªú
        network = protocol_network_analyzer.build_network_from_data(
            sample_data, 
            tvl_threshold=100000000  # 1‰∫øÁæéÂÖÉÈòàÂÄº
        )
        
        print(f"‚úÖ Network built successfully:")
        print(f"   - Nodes: {network.number_of_nodes()}")
        print(f"   - Edges: {network.number_of_edges()}")
        
        # ÊòæÁ§∫ÁΩëÁªúÊëòË¶Å
        summary = protocol_network_analyzer.get_network_summary()
        print(f"\nüìà Network Summary:")
        print(f"   - Total TVL: ${summary['total_tvl']:,.0f}")
        print(f"   - Protocols by chain:")
        for chain, data in summary['protocols_by_chain'].items():
            print(f"     ‚Ä¢ {chain}: {data['count']} protocols, ${data['tvl']:,.0f} TVL")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Network construction failed: {e}")
        return False

def test_centrality_analysis():
    """ÊµãËØï‰∏≠ÂøÉÊÄßÂàÜÊûê"""
    print("\nüìä Testing Centrality Analysis")
    print("="*50)
    
    try:
        # ËøêË°å‰∏≠ÂøÉÊÄßÂàÜÊûê
        centrality_results = protocol_network_analyzer.analyze_network_centrality()
        
        if not centrality_results:
            print("‚ùå No centrality results")
            return False
        
        print(f"‚úÖ Centrality analysis completed for {len(centrality_results)} protocols")
        
        # ÊòæÁ§∫Ââç5‰∏™ÂçèËÆÆÁöÑ‰∏≠ÂøÉÊÄßÊåáÊ†á
        print(f"\nüéØ Top 5 Protocols by Centrality:")
        sorted_protocols = sorted(
            centrality_results.items(),
            key=lambda x: x[1]['degree_centrality'] + x[1]['betweenness_centrality'],
            reverse=True
        )
        
        for i, (protocol, metrics) in enumerate(sorted_protocols[:5]):
            print(f"   {i+1}. {protocol.upper()}:")
            print(f"      ‚Ä¢ Degree Centrality: {metrics['degree_centrality']:.3f}")
            print(f"      ‚Ä¢ Betweenness Centrality: {metrics['betweenness_centrality']:.3f}")
            print(f"      ‚Ä¢ Closeness Centrality: {metrics['closeness_centrality']:.3f}")
            print(f"      ‚Ä¢ TVL: ${metrics['tvl_usd']:,.0f}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Centrality analysis failed: {e}")
        return False

def test_critical_protocols():
    """ÊµãËØïÂÖ≥ÈîÆÂçèËÆÆËØÜÂà´"""
    print("\nüéØ Testing Critical Protocols Identification")
    print("="*50)
    
    try:
        # ËØÜÂà´ÂÖ≥ÈîÆÂçèËÆÆ
        critical_protocols = protocol_network_analyzer.identify_critical_protocols(top_n=5)
        
        if not critical_protocols:
            print("‚ùå No critical protocols identified")
            return False
        
        print(f"‚úÖ Identified {len(critical_protocols)} critical protocols:")
        
        for i, protocol_info in enumerate(critical_protocols):
            print(f"\n   {i+1}. {protocol_info['protocol'].upper()} ({protocol_info['chain']})")
            print(f"      ‚Ä¢ Importance Score: {protocol_info['importance_score']:.3f}")
            print(f"      ‚Ä¢ TVL: ${protocol_info['tvl_usd']:,.0f}")
            print(f"      ‚Ä¢ Centrality Metrics:")
            metrics = protocol_info['centrality_metrics']
            print(f"        - Degree: {metrics['degree_centrality']:.3f}")
            print(f"        - Betweenness: {metrics['betweenness_centrality']:.3f}")
            print(f"        - Closeness: {metrics['closeness_centrality']:.3f}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Critical protocols identification failed: {e}")
        return False

def test_systemic_risk():
    """ÊµãËØïÁ≥ªÁªüÊÄßÈ£éÈô©ÂàÜÊûê"""
    print("\n‚ö†Ô∏è Testing Systemic Risk Analysis")
    print("="*50)
    
    try:
        # ÂàÜÊûêÁ≥ªÁªüÊÄßÈ£éÈô©
        risk_analysis = protocol_network_analyzer.analyze_systemic_risk()
        
        if not risk_analysis:
            print("‚ùå No risk analysis results")
            return False
        
        print(f"‚úÖ Systemic risk analysis completed:")
        print(f"   ‚Ä¢ Network Density: {risk_analysis['network_density']:.3f}")
        print(f"   ‚Ä¢ Clustering Coefficient: {risk_analysis['clustering_coefficient']:.3f}")
        print(f"   ‚Ä¢ Connected Components: {risk_analysis['connected_components']}")
        print(f"   ‚Ä¢ Largest Component Size: {risk_analysis['largest_component_size']}")
        print(f"   ‚Ä¢ Overall Risk Score: {risk_analysis['risk_score']:.3f}")
        
        if risk_analysis['vulnerabilities']:
            print(f"\n‚ö†Ô∏è Identified Vulnerabilities:")
            for vuln in risk_analysis['vulnerabilities']:
                print(f"   ‚Ä¢ {vuln}")
        else:
            print(f"\n‚úÖ No major vulnerabilities identified")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Systemic risk analysis failed: {e}")
        return False

def test_contagion_simulation():
    """ÊµãËØï‰º†ÊüìÊïàÂ∫îÊ®°Êãü"""
    print("\nü¶† Testing Contagion Simulation")
    print("="*50)
    
    try:
        # ÈÄâÊã©‰∏Ä‰∏™È´òTVLÂçèËÆÆ‰Ωú‰∏∫ÂàùÂßãÂÜ≤Âáª
        initial_shock = ['lido']  # LidoÊúâÊúÄÈ´òÁöÑTVL
        
        # ËøêË°å‰º†ÊüìÊ®°Êãü
        contagion_result = protocol_network_analyzer.simulate_contagion(
            initial_shock_protocols=initial_shock,
            shock_magnitude=0.6
        )
        
        print(f"‚úÖ Contagion simulation completed:")
        print(f"   ‚Ä¢ Initial Shock Protocols: {', '.join(contagion_result['initial_protocols'])}")
        print(f"   ‚Ä¢ Total Affected Protocols: {len(contagion_result['affected_protocols'])}")
        print(f"   ‚Ä¢ Total TVL Affected: ${contagion_result['total_tvl_affected']:,.0f}")
        print(f"   ‚Ä¢ Contagion Rounds: {len(contagion_result['contagion_rounds'])}")
        print(f"   ‚Ä¢ Contagion Stopped: {contagion_result['contagion_stopped']}")
        
        if contagion_result['contagion_rounds']:
            print(f"\nüìà Contagion Spread:")
            for round_info in contagion_result['contagion_rounds']:
                print(f"   Round {round_info['round']}: {len(round_info['new_affected'])} new protocols affected")
                print(f"     New: {', '.join(round_info['new_affected'])}")
        
        # ËÆ°ÁÆóÂΩ±ÂìçÊØî‰æã
        total_protocols = len(protocol_network_analyzer.protocol_data)
        if total_protocols > 0:
            impact_ratio = len(contagion_result['affected_protocols']) / total_protocols
            print(f"\nüìä Impact Analysis:")
            print(f"   ‚Ä¢ Protocols Affected: {len(contagion_result['affected_protocols'])}/{total_protocols} ({impact_ratio:.1%})")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Contagion simulation failed: {e}")
        return False

def test_data_export():
    """ÊµãËØïÊï∞ÊçÆÂØºÂá∫"""
    print("\nüíæ Testing Data Export")
    print("="*50)
    
    try:
        # ÂØºÂá∫ÁΩëÁªúÊï∞ÊçÆ
        export_data = protocol_network_analyzer.export_network_data()
        
        print(f"‚úÖ Network data exported successfully:")
        print(f"   ‚Ä¢ Network Summary: {len(export_data['network_summary'])} fields")
        print(f"   ‚Ä¢ Protocol Data: {len(export_data['protocol_data'])} protocols")
        print(f"   ‚Ä¢ Analysis Results: {len(export_data['analysis_results'])} analyses")
        print(f"   ‚Ä¢ Network Edges: {len(export_data['network_edges'])} edges")
        
        # ÊòæÁ§∫ÂàÜÊûêÁªìÊûúÁ±ªÂûã
        if export_data['analysis_results']:
            print(f"   ‚Ä¢ Available Analyses: {', '.join(export_data['analysis_results'].keys())}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Data export failed: {e}")
        return False

async def main():
    """‰∏ªÊµãËØïÂáΩÊï∞"""
    print("üî¨ OnChain Macro Analysis - Network Analysis Test")
    print("="*60)
    
    test_results = {}
    
    # ËøêË°åÊâÄÊúâÊµãËØï
    tests = [
        ("Network Construction", test_network_construction),
        ("Centrality Analysis", test_centrality_analysis),
        ("Critical Protocols", test_critical_protocols), 
        ("Systemic Risk", test_systemic_risk),
        ("Contagion Simulation", test_contagion_simulation),
        ("Data Export", test_data_export)
    ]
    
    passed_tests = 0
    
    for test_name, test_func in tests:
        try:
            if asyncio.iscoroutinefunction(test_func):
                result = await test_func()
            else:
                result = test_func()
            
            test_results[test_name] = result
            if result:
                passed_tests += 1
                
        except Exception as e:
            print(f"‚ùå Test '{test_name}' failed with error: {e}")
            test_results[test_name] = False
    
    # ÊµãËØïÊÄªÁªì
    print("\n" + "="*60)
    print("üìä TEST SUMMARY")
    print("="*60)
    
    for test_name, result in test_results.items():
        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
        print(f"   {test_name}: {status}")
    
    print(f"\nüéØ Overall Result: {passed_tests}/{len(tests)} tests passed")
    
    if passed_tests == len(tests):
        print("\nüéâ All network analysis tests passed!")
        print("üöÄ Your DeFi network analysis system is ready!")
        print("\nüìñ What you can do now:")
        print("   1. Analyze real DeFi protocol relationships")
        print("   2. Identify systemic risks in the ecosystem")
        print("   3. Simulate market contagion effects")
        print("   4. Find critical protocols for macro analysis")
    else:
        print(f"\n‚ö†Ô∏è {len(tests) - passed_tests} tests failed. Check the output above.")
    
    input("\nPress Enter to exit...")
    return 0 if passed_tests == len(tests) else 1

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\nTest interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"Test execution failed: {e}")
        sys.exit(1)